"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const error_list_1 = __importDefault(require("../../../errors/error-list"));
const async_event_emitter_1 = __importDefault(require("../../../utils/async-event-emitter"));
const interfaces_1 = require("./interfaces");
const prerender_callsite_1 = __importDefault(require("../../../utils/prerender-callsite"));
class IPCProxy extends async_event_emitter_1.default {
    constructor(transport) {
        super();
        this._requestCounter = 0;
        this._transport = transport;
        this._handlers = {};
        this._transport.read();
        this._transport.on(interfaces_1.IPCTransportEvents.data, rawPacket => this._onRead(rawPacket));
        this.on('request', data => this._onRequest(data));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _saveError(error) {
        if (interfaces_1.isTestCafeErrorList(error)) {
            for (const item of error.items) {
                if (item.callsite)
                    item.callsite = prerender_callsite_1.default(item.callsite);
            }
            return error;
        }
        return Object.assign({ name: error.name, message: error.message, stack: error.stack }, error);
    }
    async _onRead(packet) {
        if (packet.type === interfaces_1.IPCPacketType.response)
            this.emit(`response-${packet.id}`, packet);
        else
            this.emit('request', packet);
    }
    async _onRequest(requestPacket) {
        let resultData = null;
        try {
            resultData = { result: await this._handlers[requestPacket.data.name](...requestPacket.data.args) };
        }
        catch (error) {
            resultData = { error: this._saveError(error) };
        }
        const responsePacket = {
            id: requestPacket.id,
            type: interfaces_1.IPCPacketType.response,
            sync: requestPacket.sync,
            data: resultData
        };
        await this._transport.write(responsePacket);
    }
    _createPacket(opts) {
        return {
            id: this._requestCounter++,
            type: interfaces_1.IPCPacketType.request,
            sync: opts.sync,
            data: opts.data
        };
    }
    _createPlainError(errorData) {
        const error = new Error(errorData.message);
        Object.assign(error, errorData);
        return error;
    }
    _createError(errorData) {
        if (interfaces_1.isTestCafeErrorList(errorData)) {
            const errorList = new error_list_1.default();
            errorList.items = errorData.items;
            return errorList;
        }
        return this._createPlainError(errorData);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    register(func, context = null) {
        if (this._handlers[func.name])
            return;
        this._handlers[func.name] = func.bind(context);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async call(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const packet = this._createPacket({ data: { name, args }, sync: false });
        const responsePromise = this.once(`response-${packet.id}`);
        await this._transport.write(packet);
        const { data } = await responsePromise;
        if (interfaces_1.isIPCErrorResponse(data))
            throw this._createError(data.error);
        return data.result;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callSync(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const requestPacket = this._createPacket({ data: { name, args }, sync: true });
        this._transport.writeSync(requestPacket);
        let responsePacket = this._transport.readSync();
        while (responsePacket.id !== requestPacket.id)
            responsePacket = this._transport.readSync();
        const response = responsePacket.data;
        if (interfaces_1.isIPCErrorResponse(response))
            throw this._createError(response.error);
        return response.result;
    }
}
exports.IPCProxy = IPCProxy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2VydmljZXMvdXRpbHMvaXBjL3Byb3h5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsNEVBQTJEO0FBQzNELDZGQUE4RDtBQUU5RCw2Q0Fhc0I7QUFFdEIsMkZBQWtFO0FBUWxFLE1BQWEsUUFBUyxTQUFRLDZCQUFZO0lBS3RDLFlBQW9CLFNBQXVCO1FBQ3ZDLEtBQUssRUFBRSxDQUFDO1FBSkosb0JBQWUsR0FBVyxDQUFDLENBQUM7UUFNaEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7UUFFNUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxFQUFFLENBQUM7UUFFcEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQywrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7UUFDbEYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUVELDhEQUE4RDtJQUN0RCxVQUFVLENBQUUsS0FBb0I7UUFDcEMsSUFBSSxnQ0FBbUIsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUM1QixLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUU7Z0JBQzVCLElBQUksSUFBSSxDQUFDLFFBQVE7b0JBQ2IsSUFBSSxDQUFDLFFBQVEsR0FBRyw0QkFBaUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDeEQ7WUFFRCxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELHVCQUFTLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8s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a0IsQ0FBQyxRQUFRLENBQUM7WUFDNUIsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QyxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDM0IsQ0FBQztDQUNKO0FBbklELDRCQW1JQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXN0Q2FmZUVycm9yTGlzdCBmcm9tICcuLi8uLi8uLi9lcnJvcnMvZXJyb3ItbGlzdCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uLy4uLy4uL3V0aWxzL2FzeW5jLWV2ZW50LWVtaXR0ZXInO1xuXG5pbXBvcnQge1xuICAgIEV4dGVybmFsRXJyb3IsXG4gICAgaXNUZXN0Q2FmZUVycm9yTGlzdCxcblxuICAgIElQQ1BhY2tldCxcbiAgICBJUENQYWNrZXRUeXBlLFxuICAgIElQQ1JlcXVlc3RQYWNrZXQsXG4gICAgSVBDUmVzcG9uc2VQYWNrZXQsXG4gICAgSVBDUmVxdWVzdERhdGEsXG4gICAgaXNJUENFcnJvclJlc3BvbnNlLFxuXG4gICAgSVBDVHJhbnNwb3J0RXZlbnRzLFxuICAgIElQQ1RyYW5zcG9ydCxcbn0gZnJvbSAnLi9pbnRlcmZhY2VzJztcblxuaW1wb3J0IHByZXJlbmRlckNhbGxzaXRlIGZyb20gJy4uLy4uLy4uL3V0aWxzL3ByZXJlbmRlci1jYWxsc2l0ZSc7XG5cblxuaW50ZXJmYWNlIFJlcXVlc3RPcHRpb25zIHtcbiAgICBkYXRhOiBJUENSZXF1ZXN0RGF0YTtcbiAgICBzeW5jOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgSVBDUHJveHkgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIHByaXZhdGUgX3RyYW5zcG9ydDogSVBDVHJhbnNwb3J0O1xuICAgIHByaXZhdGUgX3JlcXVlc3RDb3VudGVyOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2hhbmRsZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBGdW5jdGlvbiB9O1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICh0cmFuc3BvcnQ6IElQQ1RyYW5zcG9ydCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5yZWFkKCk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5vbihJUENUcmFuc3BvcnRFdmVudHMuZGF0YSwgcmF3UGFja2V0ID0+IHRoaXMuX29uUmVhZChyYXdQYWNrZXQpKTtcbiAgICAgICAgdGhpcy5vbigncmVxdWVzdCcsIGRhdGEgPT4gdGhpcy5fb25SZXF1ZXN0KGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHByaXZhdGUgX3NhdmVFcnJvciAoZXJyb3I6IEV4dGVybmFsRXJyb3IpOiBhbnkge1xuICAgICAgICBpZiAoaXNUZXN0Q2FmZUVycm9yTGlzdChlcnJvcikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlcnJvci5pdGVtcykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNhbGxzaXRlKVxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxzaXRlID0gcHJlcmVuZGVyQ2FsbHNpdGUoaXRlbS5jYWxsc2l0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IG5hbWU6IGVycm9yLm5hbWUsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjaywgLi4uZXJyb3IgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9vblJlYWQgKHBhY2tldDogSVBDUGFja2V0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChwYWNrZXQudHlwZSA9PT0gSVBDUGFja2V0VHlwZS5yZXNwb25zZSlcbiAgICAgICAgICAgIHRoaXMuZW1pdChgcmVzcG9uc2UtJHtwYWNrZXQuaWR9YCwgcGFja2V0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgcGFja2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFzeW5jIF9vblJlcXVlc3QgKHJlcXVlc3RQYWNrZXQ6IElQQ1JlcXVlc3RQYWNrZXQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbGV0IHJlc3VsdERhdGEgPSBudWxsO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHREYXRhID0geyByZXN1bHQ6IGF3YWl0IHRoaXMuX2hhbmRsZXJzW3JlcXVlc3RQYWNrZXQuZGF0YS5uYW1lXSguLi5yZXF1ZXN0UGFja2V0LmRhdGEuYXJncykgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdERhdGEgPSB7IGVycm9yOiB0aGlzLl9zYXZlRXJyb3IoZXJyb3IpIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNwb25zZVBhY2tldDogSVBDUmVzcG9uc2VQYWNrZXQgPSB7XG4gICAgICAgICAgICBpZDogICByZXF1ZXN0UGFja2V0LmlkLFxuICAgICAgICAgICAgdHlwZTogSVBDUGFja2V0VHlwZS5yZXNwb25zZSxcbiAgICAgICAgICAgIHN5bmM6IHJlcXVlc3RQYWNrZXQuc3luYyxcblxuICAgICAgICAgICAgZGF0YTogcmVzdWx0RGF0YVxuICAgICAgICB9O1xuXG4gICAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydC53cml0ZShyZXNwb25zZVBhY2tldCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY3JlYXRlUGFja2V0IChvcHRzOiBSZXF1ZXN0T3B0aW9ucyk6IElQQ1JlcXVlc3RQYWNrZXQge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6ICAgdGhpcy5fcmVxdWVzdENvdW50ZXIrKyxcbiAgICAgICAgICAgIHR5cGU6IElQQ1BhY2tldFR5cGUucmVxdWVzdCxcbiAgICAgICAgICAgIHN5bmM6IG9wdHMuc3luYyxcbiAgICAgICAgICAgIGRhdGE6IG9wdHMuZGF0YVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZVBsYWluRXJyb3IgKGVycm9yRGF0YTogRXJyb3IpOiBFcnJvciB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGVycm9yRGF0YS5tZXNzYWdlKTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGVycm9yLCBlcnJvckRhdGEpO1xuXG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jcmVhdGVFcnJvciAoZXJyb3JEYXRhOiBFeHRlcm5hbEVycm9yKTogRXh0ZXJuYWxFcnJvciB7XG4gICAgICAgIGlmIChpc1Rlc3RDYWZlRXJyb3JMaXN0KGVycm9yRGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTGlzdCA9IG5ldyBUZXN0Q2FmZUVycm9yTGlzdCgpO1xuXG4gICAgICAgICAgICBlcnJvckxpc3QuaXRlbXMgPSBlcnJvckRhdGEuaXRlbXM7XG5cbiAgICAgICAgICAgIHJldHVybiBlcnJvckxpc3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlUGxhaW5FcnJvcihlcnJvckRhdGEpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcHVibGljIHJlZ2lzdGVyIChmdW5jOiBGdW5jdGlvbiwgY29udGV4dDogYW55ID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZnVuYy5uYW1lXSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tmdW5jLm5hbWVdID0gZnVuYy5iaW5kKGNvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcHVibGljIGFzeW5jIGNhbGwgKHRhcmdldDogc3RyaW5nfEZ1bmN0aW9uLCAuLi5hcmdzOiBhbnlbXSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgICAgICAgICAgICA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGNvbnN0IHBhY2tldCAgICAgICAgICA9IHRoaXMuX2NyZWF0ZVBhY2tldCh7IGRhdGE6IHsgbmFtZSwgYXJncyB9LCBzeW5jOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5vbmNlKGByZXNwb25zZS0ke3BhY2tldC5pZH1gKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQud3JpdGUocGFja2V0KTtcblxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcblxuICAgICAgICBpZiAoaXNJUENFcnJvclJlc3BvbnNlKGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoZGF0YS5lcnJvcik7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcHVibGljIGNhbGxTeW5jICh0YXJnZXQ6IHN0cmluZ3xGdW5jdGlvbiwgLi4uYXJnczogYW55W10pOiBhbnkge1xuICAgICAgICBjb25zdCBuYW1lICAgICAgICAgID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiB0YXJnZXQubmFtZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhY2tldCA9IHRoaXMuX2NyZWF0ZVBhY2tldCh7IGRhdGE6IHsgbmFtZSwgYXJncyB9LCBzeW5jOiB0cnVlIH0pO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC53cml0ZVN5bmMocmVxdWVzdFBhY2tldCk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlUGFja2V0OiBJUENSZXNwb25zZVBhY2tldCA9IHRoaXMuX3RyYW5zcG9ydC5yZWFkU3luYygpO1xuXG4gICAgICAgIHdoaWxlIChyZXNwb25zZVBhY2tldC5pZCAhPT0gcmVxdWVzdFBhY2tldC5pZClcbiAgICAgICAgICAgIHJlc3BvbnNlUGFja2V0ID0gdGhpcy5fdHJhbnNwb3J0LnJlYWRTeW5jKCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZVBhY2tldC5kYXRhO1xuXG4gICAgICAgIGlmIChpc0lQQ0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IocmVzcG9uc2UuZXJyb3IpO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxufVxuIl19